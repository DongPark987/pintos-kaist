#include "threads/interrupt.h"

#include <debug.h>
#include <inttypes.h>
#include <stdint.h>
#include <stdio.h>

#include "devices/timer.h"
#include "intrinsic.h"
#include "threads/flags.h"
#include "threads/intr-stubs.h"
#include "threads/io.h"
#include "threads/mmu.h"
#include "threads/thread.h"
#include "threads/vaddr.h"
#ifdef USERPROG
#include "userprog/gdt.h"
#endif

/* Number of x86_64 interrupts. */
#define INTR_CNT 256

/* Creates an gate that invokes FUNCTION.

   The gate has descriptor privilege level DPL, meaning that it
   can be invoked intentionally when the processor is in the DPL
   or lower-numbered ring.  In practice, DPL==3 allows user mode
   to call into the gate and DPL==0 prevents such calls.  Faults
   and exceptions that occur in user mode still cause gates with
   DPL==0 to be invoked.

   TYPE must be either 14 (for an interrupt gate) or 15 (for a
   trap gate).  The difference is that entering an interrupt gate
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion.
   FUNCTION을 호출하는 게이트를 생성합니다.

   게이트는 디스크립터 권한 레벨(DPL)을 가지며, 이는 프로세서가 DPL 또는 더
   낮은 번호의 링에 있을 때 의도적으로 호출될 수 있다는 것을 의미합니다. 실제로,
   DPL==3은 사용자 모드에서 게이트를 호출할 수 있게 하며, DPL==0은 그러한 호출을
   방지합니다. 사용자 모드에서 발생하는 오류와 예외는 DPL==0을 가진 게이트가
   호출되도록 합니다.

   TYPE은 인터럽트 게이트를 위한 14 또는 트랩 게이트를 위한 15 중 하나여야
   합니다. 차이점은 인터럽트 게이트에 들어가면 인터럽트가 비활성화되지만, 트랩
   게이트에 들어가면 그렇지 않다는 것입니다. 이에 대한 논의는 [IA32-v3a]
   섹션 5.12.1.2 "예외 또는 인터럽트 핸들러 프로시저에 의한 플래그 사용"을
   참조하십시오. */

struct gate {
  unsigned off_15_0 : 16;   // low 16 bits of offset in segment
  unsigned ss : 16;         // segment selector
  unsigned ist : 3;         // # args, 0 for interrupt/trap gates
  unsigned rsv1 : 5;        // reserved(should be zero I guess)
  unsigned type : 4;        // type(STS_{TG,IG32,TG32})
  unsigned s : 1;           // must be 0 (system)
  unsigned dpl : 2;         // descriptor(meaning new) privilege level
  unsigned p : 1;           // Present
  unsigned off_31_16 : 16;  // high bits of offset in segment
  uint32_t off_32_63;
  uint32_t rsv2;
};

/* The Interrupt Descriptor Table (IDT).  The format is fixed by
   the CPU.  See [IA32-v3a] sections 5.10 "Interrupt Descriptor
   Table (IDT)", 5.11 "IDT Descriptors", 5.12.1.2 "Flag Usage By
   Exception- or Interrupt-Handler Procedure". */
static struct gate idt[INTR_CNT];

static struct desc_ptr idt_desc = {.size = sizeof(idt) - 1,
                                   .address = (uint64_t)idt};

#define make_gate(g, function, d, t)                            \
  {                                                             \
    ASSERT((function) != NULL);                                 \
    ASSERT((d) >= 0 && (d) <= 3);                               \
    ASSERT((t) >= 0 && (t) <= 15);                              \
    *(g) = (struct gate){                                       \
        .off_15_0 = (uint64_t)(function) & 0xffff,              \
        .ss = SEL_KCSEG,                                        \
        .ist = 0,                                               \
        .rsv1 = 0,                                              \
        .type = (t),                                            \
        .s = 0,                                                 \
        .dpl = (d),                                             \
        .p = 1,                                                 \
        .off_31_16 = ((uint64_t)(function) >> 16) & 0xffff,     \
        .off_32_63 = ((uint64_t)(function) >> 32) & 0xffffffff, \
        .rsv2 = 0,                                              \
    };                                                          \
  }

/* Creates an interrupt gate that invokes FUNCTION with the given DPL. */
#define make_intr_gate(g, function, dpl) make_gate((g), (function), (dpl), 14)

/* Creates a trap gate that invokes FUNCTION with the given DPL. */
#define make_trap_gate(g, function, dpl) make_gate((g), (function), (dpl), 15)

/* Interrupt handler functions for each interrupt. */
static intr_handler_func *intr_handlers[INTR_CNT];

/* Names for each interrupt, for debugging purposes. */
static const char *intr_names[INTR_CNT];

/* External interrupts are those generated by devices outside the
   CPU, such as the timer.  External interrupts run with
   interrupts turned off, so they never nest, nor are they ever
   pre-empted.  Handlers for external interrupts also may not
   sleep, although they may invoke intr_yield_on_return() to
   request that a new process be scheduled just before the
   interrupt returns.

   외부 인터럽트는 타이머와 같은 CPU 외부의 장치에 의해 생성되는 인터럽트입니다.
   외부 인터럽트는 인터럽트가 꺼진 상태에서 실행되므로 중첩되지 않으며, 또한
   선점되지도 않습니다. 외부 인터럽트의 핸들러는 잠들 수 없지만, 인터럽트가
   반환되기 직전에 새로운 프로세스가 스케줄링되도록 intr_yield_on_return()를
   호출할 수 있습니다. */
static bool in_external_intr; /* Are we processing an external interrupt? */
static bool yield_on_return;  /* Should we yield on interrupt return? */

/* Programmable Interrupt Controller helpers. */
static void pic_init(void);
static void pic_end_of_interrupt(int irq);

/* Interrupt handlers. */
void intr_handler(struct intr_frame *args);

/* Returns the current interrupt status. */
enum intr_level intr_get_level(void) {
  uint64_t flags;

  /* Push the flags register on the processor stack, then pop the
     value off the stack into `flags'.  See [IA32-v2b] "PUSHF"
     and "POP" and [IA32-v3a] 5.8.1 "Masking Maskable Hardware
     Interrupts".

     플래그 레지스터를 프로세서 스택에 푸시한 다음, 스택에서 값을 팝하여
     `flags`에 저장합니다. [IA32-v2b]의 "PUSHF"와 "POP" 및 [IA32-v3a] 5.8.1
     "Masking Maskable Hardware Interrupts"를 참조하십시오.

     플래그 레지스터의 상태를 임시로 스택에 저장하고 다시 팝해서 플래그에 저장
     그리고 그 값을 리턴한다. */
  asm volatile("pushfq; popq %0" : "=g"(flags));

  /* IF비트는 플래그 레지스터의 9번째에 있으므로,
     FLAG_IF (1 << 9)로 마스킹한다. */
  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
}

/* Enables or disables interrupts as specified by LEVEL and
   returns the previous interrupt status.
   인자로 주어진 값으로 인터럽트 레벨을 설정하고 이전 상태를 반환한다. */
enum intr_level intr_set_level(enum intr_level level) {
  return level == INTR_ON ? intr_enable() : intr_disable();
}

/* Enables interrupts and returns the previous interrupt status.
   인터럽트를 허용하고, 이전의 인터럽트 상태 반환 */
enum intr_level intr_enable(void) {
  enum intr_level old_level = intr_get_level();
  ASSERT(!intr_context()); /* 현재 인터럽트를 처리 중이 아니어야 한다. */

  /* Enable interrupts by setting the interrupt flag.

     See [IA32-v2b] "STI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts".

     sti (set interrupt flag)는 인터럽트 플래그를 제어하는 어셈블리 명령어
     인터럽트 플래그(IF)는 단일비트로 프로세서의 플래그 레지스터 EFLAG에 있다.
     sti는 인터럽트를 처리 가능한 상태 INTR_ON 으로 설정한다.
     IF가 켜지면, 현재 인터럽트를 중단할 수 있는 인터럽트가 들어오면 현재
     처리중인 것을 중단하고 먼저 실행할 수 있다.
      */

  /* 의문
   ! 마스킹 할 수 없는 인터럽트도 있을 것 같다.
   ! 여러 개의 인터럽트를 처리하고자 큐에 쌓으면 안 될까? */
  asm volatile("sti");

  return old_level;
}

/* Disables interrupts and returns the previous interrupt status.
   인터럽트 처리를 비허용하고 이전의 인터럽트 상태를 반환한다 */
enum intr_level intr_disable(void) {
  enum intr_level old_level = intr_get_level();

  /* Disable interrupts by clearing the interrupt flag.

     See [IA32-v2b] "CLI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts".

     cli (clear interrupt flag) 는 인터럽트 플래그 비트를 꺼서
     현재 인터럽트 처리를 중단(마스킹)할 수 있는 인터럽트를 무시한다.
     */
  asm volatile("cli" : : : "memory");

  return old_level;
}

/* Initializes the interrupt system. */
void intr_init(void) {
  int i;

  /* Initialize interrupt controller. */
  pic_init();

  /* Initialize IDT.
     *IDT(Interrupt Descriptor Table)은 각 인터럽트 벡터와
     인터럽트 발생 시의 핸들러의 주소값을 매핑한다. 외부 인터럽트가 발생하면
     장치는 인터럽트 벡터값을 같이 보내오고, 프로세서는 벡터값을 이 테이블에서
     찾아 인터럽트 핸들러를 실행한다. 이 테이블은 일반적으로 모든 시스템에서
     단일하다. */
  for (i = 0; i < INTR_CNT; i++) {
    /* &idt[i]에 intr_stubs[i] */
    make_intr_gate(&idt[i], intr_stubs[i], 0);
    intr_names[i] = "unknown";
  }

#ifdef USERPROG
  /* Load TSS. */
  ltr(SEL_TSS);
#endif

  /* Load IDT register.
    Interrupt Descriptor Table Register (IDTR)에 값을 로드
    ! 여기서는 레지스터와 테이블의 주소를 매핑하는걸까? */
  lidt(&idt_desc);

  /* Initialize intr_names.
    소프트웨어 인터럽트를 쭉 나열 (이 정보는 이미 갖고 있음) */
  intr_names[0] = "#DE Divide Error";
  intr_names[1] = "#DB Debug Exception";
  intr_names[2] = "NMI Interrupt";
  intr_names[3] = "#BP Breakpoint Exception";
  intr_names[4] = "#OF Overflow Exception";
  intr_names[5] = "#BR BOUND Range Exceeded Exception";
  intr_names[6] = "#UD Invalid Opcode Exception";
  intr_names[7] = "#NM Device Not Available Exception";
  intr_names[8] = "#DF Double Fault Exception";
  intr_names[9] = "Coprocessor Segment Overrun";
  intr_names[10] = "#TS Invalid TSS Exception";
  intr_names[11] = "#NP Segment Not Present";
  intr_names[12] = "#SS Stack Fault Exception";
  intr_names[13] = "#GP General Protection Exception";
  intr_names[14] = "#PF Page-Fault Exception";
  intr_names[16] = "#MF x87 FPU Floating-Point Error";
  intr_names[17] = "#AC Alignment Check Exception";
  intr_names[18] = "#MC Machine-Check Exception";
  intr_names[19] = "#XF SIMD Floating-Point Exception";
}

/* Registers interrupt VEC_NO to invoke HANDLER with descriptor
   privilege level DPL.  Names the interrupt NAME for debugging
   purposes.  The interrupt handler will be invoked with
   interrupt status set to LEVEL.

   인터럽트 VEC_NO를 디스크립터 권한 레벨 DPL을 가진 HANDLER를 호출하도록
   등록합니다. 디버깅 목적으로 인터럽트에 NAME을 이름으로 지정합니다. 인터럽트
   핸들러는 인터럽트 상태가 LEVEL로 설정된 상태로 호출됩니다.

   IDT에 인터럽트 벡터와 핸들러를 매핑한다. 인터럽트가 발생하면 핸들러를 실행 */
static void register_handler(uint8_t vec_no, int dpl, enum intr_level level,
                             intr_handler_func *handler, const char *name) {
  ASSERT(intr_handlers[vec_no] == NULL);
  if (level == INTR_ON) {
    make_trap_gate(&idt[vec_no], intr_stubs[vec_no], dpl);
  } else {
    make_intr_gate(&idt[vec_no], intr_stubs[vec_no], dpl);
  }
  intr_handlers[vec_no] = handler; /* 0x20 timer_interrupt */
  intr_names[vec_no] = name;       /* for debug */
}

/* Registers external interrupt VEC_NO to invoke HANDLER, which
   is named NAME for debugging purposes.  The handler will
   execute with interrupts disabled.

   interrupt off 상태로 핸들러 매핑을 명령. */
void intr_register_ext(uint8_t vec_no, intr_handler_func *handler,
                       const char *name) {
  ASSERT(vec_no >= 0x20 && vec_no <= 0x2f);
  register_handler(vec_no, 0, INTR_OFF, handler, name);
}

/* Registers internal interrupt VEC_NO to invoke HANDLER, which
   is named NAME for debugging purposes.  The interrupt handler
   will be invoked with interrupt status LEVEL.

   The handler will have descriptor privilege level DPL, meaning
   that it can be invoked intentionally when the processor is in
   the DPL or lower-numbered ring.  In practice, DPL==3 allows
   user mode to invoke the interrupts and DPL==0 prevents such
   invocation.  Faults and exceptions that occur in user mode
   still cause interrupts with DPL==0 to be invoked.  See
   [IA32-v3a] sections 4.5 "Privilege Levels" and 4.8.1.1
   "Accessing Nonconforming Code Segments" for further
   discussion.

   내부 인터럽트 VEC_NO를 등록하여 HANDLER를 호출합니다. 이 핸들러는 디버깅을
   위해 NAME이라는 이름으로 지정됩니다. 인터럽트 핸들러는 인터럽트 상태 LEVEL로
   호출됩니다.

   핸들러는 디스크립터 권한 레벨 DPL을 가지게 됩니다. 이는 프로세서가 DPL 또는
   더 낮은 숫자의 링에 있을 때 의도적으로 호출될 수 있음을 의미합니다. 실제로,
   DPL==3은 사용자 모드에서 인터럽트를 호출할 수 있게 하며 DPL==0은 그러한
   호출을 방지합니다. 사용자 모드에서 발생하는 장애와 예외는 DPL==0인 인터럽트도
   호출하게 됩니다. 더 자세한 내용은 [IA32-v3a]의 4.5절 "Privilege
   Levels"와 4.8.1.1 "Accessing Nonconforming Code Segments"를 참조하십시오. */
void intr_register_int(uint8_t vec_no, int dpl, enum intr_level level,
                       intr_handler_func *handler, const char *name) {
  ASSERT(vec_no < 0x20 || vec_no > 0x2f);
  register_handler(vec_no, dpl, level, handler, name);
}

/* Returns true during processing of an external interrupt
   and false at all other times.
   현재 외부 인터럽트 처리 중인지를 반환 */
bool intr_context(void) { return in_external_intr; }

/* During processing of an external interrupt, directs the
   interrupt handler to yield to a new process just before
   returning from the interrupt.  May not be called at any other
   time.
   외부 인터럽트(timer interrupt) 처리 중에, 인터럽트 핸들러가 인터럽트로부터
   리턴하기 직전에 새로운 프로세스로 양보하도록 지시한다. 다른 시간에는 호출될
   수 없다. */
void intr_yield_on_return(void) {
  ASSERT(intr_context());
  yield_on_return = true;
}

/* 8259A Programmable Interrupt Controller. */

/* Every PC has two 8259A Programmable Interrupt Controller (PIC)
   chips.  One is a "master" accessible at ports 0x20 and 0x21.
   The other is a "slave" cascaded onto the master's IRQ 2 line
   and accessible at ports 0xa0 and 0xa1.  Accesses to port 0x20
   set the A0 line to 0 and accesses to 0x21 set the A1 line to
   1.  The situation is similar for the slave PIC.

   By default, interrupts 0...15 delivered by the PICs will go to
   interrupt vectors 0...15.  Unfortunately, those vectors are
   also used for CPU traps and exceptions.  We reprogram the PICs
   so that interrupts 0...15 are delivered to interrupt vectors
   32...47 (0x20...0x2f) instead.

   PC는 두 개의 8259A 프로그래머블 인터럽트 컨트롤러 (PIC) 칩이 있습니다.
   하나는 포트 0x20 및 0x21에서 액세스 할 수 있는 "마스터"입니다. 다른 하나는
   마스터의 IRQ 2 라인에 연결된 "슬레이브"로 포트 0xa0 및 0xa1에서 액세스 할 수
    있습니다. 포트 0x20에 대한 액세스는 A0 라인을 0으로 설정하고 포트 0x21에
   대한 액세스는 A1 라인을 1로 설정합니다. 슬레이브 PIC에 대해서도 상황이
   비슷합니다.

   기본적으로 PIC에 의해 전달되는 인터럽트 0...15는 인터럽트 벡터 0...15로
   전달됩니다. 불행히도 이러한 벡터는 CPU 트랩 및 예외에도 사용됩니다. 따라서
   우리는 PIC를 다시 프로그래밍하여 인터럽트 0...15가 인터럽트 벡터 32...47
   (0x20...0x2f)로 전달되도록 합니다.

   즉, 하드웨어 인터럽트의 벡터값이 소프트웨어 인터럽트의 벡터값과 동일하게
   PIC에 오기 때문에, 벡터값을 바꿔준다 */

/* Initializes the PICs.  Refer to [8259A] for details. */
static void pic_init(void) {
  /* Mask all interrupts on both PICs.
     일단 각 PIC의 인터럽트 라인을 마스킹하고, (중간에 방해받지 않게)  */
  outb(0x21, 0xff);
  outb(0xa1, 0xff);

  /* Initialize master.
     마스터 PIC를 초기화한다 */
  outb(0x20, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
  outb(0x21, 0x20); /* ICW2: line IR0...7 -> irq 0x20...0x27. */
  outb(0x21, 0x04); /* ICW3: slave PIC on line IR2. */
  outb(0x21, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */

  /* Initialize slave.
     슬레이브 PIC를 초기화한다 */
  outb(0xa0, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
  outb(0xa1, 0x28); /* ICW2: line IR0...7 -> irq 0x28...0x2f. */
  outb(0xa1, 0x02); /* ICW3: slave ID is 2. */
  outb(0xa1, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */

  /* Unmask all interrupts.
     다시 언마스크! */
  outb(0x21, 0x00);
  outb(0xa1, 0x00);
}

/* Sends an end-of-interrupt signal to the PIC for the given IRQ.
   If we don't acknowledge the IRQ, it will never be delivered to
   us again, so this is important.

   PIC에게 해당 IRQ에 대한 인터럽트 종료 시그널을 보낸다.
   ! IRQ는 뭐지.. */
static void pic_end_of_interrupt(int irq) {
  ASSERT(irq >= 0x20 && irq < 0x30);

  /* Acknowledge master PIC. */
  outb(0x20, 0x20);

  /* Acknowledge slave PIC if this is a slave interrupt. */
  if (irq >= 0x28) outb(0xa0, 0x20);
}

/* Interrupt handlers. */

/* Handler for all interrupts, faults, and exceptions.  This
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers.

   모든 인터럽트, 장애, 예외에 대한 핸들러입니다. 이 함수는 intr-stubs.S 내의
   어셈블리 언어 인터럽트 스텁에 의해 호출됩니다. FRAME은 인터럽트와 인터럽트 된
   스레드의 레지스터를 설명합니다. */
void intr_handler(struct intr_frame *frame) {
  bool external;
  intr_handler_func *handler;

  /* External interrupts are special.
     We only handle one at a time (so interrupts must be off)
     and they need to be acknowledged on the PIC (see below).
     An external interrupt handler cannot sleep.

     외부 인터럽트는 중요하므로 한 번에 하나씩만 처리합니다. (따라서 처리 중에는
     IF가 꺼져 있다) 또한 이 인터럽트는 PIC에서 인식되어야 합니다. 외부 인터럽트
     핸들러는 종료되지 않습니다. */

  /*
   ! 0x20은 timer interrupt, 0x30은 ? */
  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
  if (external) {
    ASSERT(intr_get_level() == INTR_OFF);  // 인터럽트 비활성화여야 함
    ASSERT(!intr_context());  // 인터럽트 처리 컨텍스트가 아니어야 함

    in_external_intr = true;  // 외부 인터럽트 처리 플래그를 true로
    yield_on_return = false;  // yield_on_return 초기화
  }

  /* Invoke the interrupt's handler. */
  handler = intr_handlers[frame->vec_no];  // idt에서 찾아온다
  if (handler != NULL)                     // 핸들러가 있으면
    handler(frame);                        // 핸들러를 실행, thread_tick
  else if (frame->vec_no == 0x27 ||
           frame->vec_no == 0x2f) {  // 없고 벡터가 얘네이면 무시
    /* There is no handler, but this interrupt can trigger
       spuriously due to a hardware fault or hardware race
       condition.  Ignore it.
       핸들러는 없지만, 하드웨어 결함이나 하드웨어 경쟁 조건으로 인해 이
       인터럽트는 잘못된 방식으로 트리거 될 수 있습니다. 무시하세요. */
  } else {
    /* No handler and not spurious.  Invoke the unexpected
       interrupt handler.
       핸들러가 없으며 잘못된 것도 아닙니다. 예기치 않은 인터럽트 핸들러를
       호출하세요. */
    intr_dump_frame(frame);
    PANIC("Unexpected interrupt");
  }

  /* Complete the processing of an external interrupt. */
  if (external) {
    ASSERT(intr_get_level() == INTR_OFF);
    ASSERT(intr_context());

    in_external_intr = false;             // 인터럽트 처리 종료
    pic_end_of_interrupt(frame->vec_no);  // pic에 인터럽트 처리 종료됨 알리기

    if (yield_on_return) {
      thread_yield();  // yield_on_return 이면 switch thread
    }
  }
}

/* Dumps interrupt frame F to the console, for debugging. */
void intr_dump_frame(const struct intr_frame *f) {
  /* CR2 is the linear address of the last page fault.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  uint64_t cr2 = rcr2();
  printf("Interrupt %#04llx (%s) at rip=%llx\n", f->vec_no,
         intr_names[f->vec_no], f->rip);
  printf(" cr2=%016llx error=%16llx\n", cr2, f->error_code);
  printf("rax %016llx rbx %016llx rcx %016llx rdx %016llx\n", f->R.rax,
         f->R.rbx, f->R.rcx, f->R.rdx);
  printf("rsp %016llx rbp %016llx rsi %016llx rdi %016llx\n", f->rsp, f->R.rbp,
         f->R.rsi, f->R.rdi);
  printf("rip %016llx r8 %016llx  r9 %016llx r10 %016llx\n", f->rip, f->R.r8,
         f->R.r9, f->R.r10);
  printf("r11 %016llx r12 %016llx r13 %016llx r14 %016llx\n", f->R.r11,
         f->R.r12, f->R.r13, f->R.r14);
  printf("r15 %016llx rflags %08llx\n", f->R.r15, f->eflags);
  printf("es: %04x ds: %04x cs: %04x ss: %04x\n", f->es, f->ds, f->cs, f->ss);
}

/* Returns the name of interrupt VEC. */
const char *intr_name(uint8_t vec) { return intr_names[vec]; }
