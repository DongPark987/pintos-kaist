# [Project1] Threads

## 1. Getting Started
 
이 과제에서는 초기 쓰레드 시스템의 기능을 확장하는 작업을 수행합니다. 동기화 문제에 대한 더 나은 이해를 위해이 시스템의 기능을 확장해야 합니다. 이 과제에서는 주로 threads 디렉토리에서 작업하며, 부수적으로 devices 디렉토리에서도 일부 작업을 수행해야 합니다. 컴파일은 주로 threads 디렉토리에서 수행해야 합니다. 이 프로젝트에 대한 설명을 읽기 전에 적어도 동기화 자료를 대략 훑어보는 것이 좋습니다.
 
### 1.1. Background
첫 번째 단계는 초기 쓰레드 시스템의 코드를 읽고 이해하는 것입니다. Pintos는 이미 쓰레드 생성 및 쓰레드 완료, 쓰레드 간 전환을 위한 간단한 스케줄러, 그리고 동기화 기본 요소 (세마포어, 락, 조건 변수 및 최적화 바리어)를 구현하고 있습니다.

 
이 코드 중 일부는 약간 신비로울 수 있습니다. 기본 시스템을 이미 컴파일하고 실행하지 않았다면, 소개에서 설명한 대로 지금 실행해 보는 것이 좋습니다. 소스 코드의 일부를 읽어보고 무슨 일이 벌어지고 있는지 살펴볼 수 있습니다. 원한다면 `printf()` 호출을 거의 어디서든 추가하고, 다시 컴파일하고 실행하여 어떤 일이 어떤 순서로 발생하는지 확인할 수 있습니다. 또한 디버거에서 커널을 실행하고 흥미로운 지점에 중단점을 설정하거나 단계별로 코드를 실행하고 데이터를 검사할 수도 있습니다.

 
쓰레드가 생성될 때, 새로운 컨텍스트가 예약됩니다. 이 컨텍스트에서 실행할 함수를 `thread_create()`에 인수로 제공합니다. 쓰레드가 처음 예약되고 실행될 때, 해당 함수의 시작부터 시작하여 해당 컨텍스트에서 실행됩니다. 함수가 반환되면 쓰레드가 종료됩니다. 따라서 각 쓰레드는 Pintos 내에서 mini-program처럼 작동하며, `thread_create()`에 전달된 함수가 main()처럼 작동합니다.

 
어떤 시점에서도 정확히 하나의 쓰레드만 실행되며, 나머지는 비활성화됩니다. 스케줄러는 어떤 쓰레드를 다음으로 실행할지 결정합니다. (어떤 시점에서 아무 쓰레드도 실행 준비가 되지 않았다면, `idle()`에서 구현된 특수한 idle 쓰레드가 실행됩니다.) 동기화 기본 요소는 한 쓰레드가 다른 쓰레드가 어떤 작업을 수행하기를 기다려야 할 때 컨텍스트 전환을 강제할 수 있습니다.

 
컨텍스트 전환의 기계적인 부분은 `threads/thread.c`의 `thread_launch()`에 있습니다. (이해할 필요는 없습니다.) 이 함수는 현재 실행 중인 쓰레드의 상태를 저장하고 전환할 쓰레드의 상태를 복원합니다.

 
GDB 디버거를 사용하여 컨텍스트 전환을 천천히 추적하여 무슨 일이 일어나는지 확인할 수 있습니다 (GDB 참조). 먼저 `schedule()`에 중단점을 설정하고 거기서부터 단계별로 진행해보세요. 각 쓰레드의 주소와 상태, 각 쓰레드에 대한 호출 스택에 어떤 프로시저가 있는지를 추적해야 합니다. `do_iret()`에서 `iret`를 실행하는 순간 다른 쓰레드가 실행되기 시작하는 것을 알게 될 것입니다.


경고: Pintos에서 각 쓰레드에는 약간의 고정 크기의 실행 스택이 할당되며 크기는 4KB 미만입니다. 커널은 스택 오버플로우를 감지하려고 시도하지만 완벽하게 감지할 수는 없습니다. 따라서 비정적 로컬 변수로 큰 데이터 구조를 선언하면 (예: `int buf[1000];`) 이상한 문제, 즉 미스터리 커널 패닉과 같은 이상한 문제를 발생시킬 수 있습니다. 스택 할당 대안으로 페이지 할당자와 블록 할당자를 사용할 수 있습니다 (메모리 할당 참조).

 
### 1.2. Source Files
다음은 `threads` 및 `include/threads` 디렉토리에 있는 파일에 대한 간략한 개요입니다. 대부분의 코드를 수정할 필요는 없지만 이 개요를 제공함으로써 어떤 코드를 살펴봐야 하는지에 대한 시작점을 제공할 것입니다.

#### threads 코드
- `loader.S`, `loader.h` 커널 로더. PC BIOS가 메모리에 로드하고, 이후 디스크에서 커널을 찾아 메모리에 로드하고 start.S의 bootstrap()로 점프하는 데 사용되는 512바이트의 코드 및 데이터로 어셈블됩니다. 이 코드를 살펴보거나 수정할 필요는 없습니다. start.S는 메모리 보호에 필요한 기본 설정 및 64비트 롱 모드로의 점프를 수행합니다. 로더와 달리 이 코드는 실제로 커널의 일부입니다.

- `kernel.lds.S` 커널을 링크하는 데 사용되는 링커 스크립트. 커널의 로드 주소를 설정하고 start.S가 커널 이미지의 시작 부분 근처에 있도록 배열합니다. 다시 말하지만, 이 코드를 살펴보거나 수정할 필요는 없지만 궁금한 경우에 대비하여 여기에 있습니다.

- `init.c`, `init.h` 커널 초기화, main()을 포함한 커널의 주요 프로그램입니다. main()을 적어도 확인하여 어떤 것이 초기화되는지 살펴볼 필요가 있습니다. 여기에 자체 초기화 코드를 추가할 수도 있습니다.

- thread.c, thread.h 기본적인 스레드 지원. 여러분의 작업 중 많은 부분이 이 파일에서 이루어질 것입니다. thread.h는 struct thread를 정의하며, 이는 모든 네 가지 프로젝트에서 수정할 가능성이 높습니다. 자세한 내용은 "Threads"를 참조하십시오.

- palloc.c, palloc.h 페이지 할당기, 4 KB 페이지의 배수로 시스템 메모리를 할당하는 것입니다. 자세한 내용은 "Page Allocator"를 참조하십시오.

- malloc.c, malloc.h 커널을 위한 malloc() 및 free()의 간단한 구현입니다. 자세한 내용은 "Block Allocator"를 참조하십시오.

- interrupt.c, interrupt.h 기본적인 인터럽트 처리 및 인터럽트를 켜고 끄는 기능입니다.

- intr-stubs.S, intr-stubs.h 저수준 인터럽트 처리를 위한 어셈블리 코드입니다.

- synch.c, synch.h 기본 동기화 기본 요소: 세마포어, 락, 조건 변수 및 최적화 바리어입니다. 네 가지 프로젝트 모두에서 동기화에 사용해야 합니다. 자세한 내용은 "Synchronization"를 참조하십시오.

- mmu.c, mmu.h x86-64 페이지 테이블 작업을 위한 함수입니다. 이 파일은 lab1 이후에 자세히 살펴보게 될 것입니다.

- io.h I/O 포트 접근을 위한 함수입니다. 이것은 주로 devices 디렉토리의 소스 코드에서 사용되며 여러분은 이를 건드릴 필요가 없습니다.

- vaddr.h, pte.h 가상 주소 및 페이지 테이블 항목과 작업하기 위한 함수 및 매크로입니다. 이것들은 프로젝트 3에서 더 중요해질 것입니다. 현재는 무시해도 됩니다.

- flags.h x86-64 플래그 레지스터의 몇 가지 비트를 정의하는 매크로입니다. 아마도 흥미로울 것이 없습니다.

 
### 1.3. `devices` 코드
기본적인 스레드 커널은 디바이스 디렉토리에 다음과 같은 파일을 포함합니다.

- timer.c, timer.h 시스템 타이머로서, 기본적으로 초당 100번 작동합니다. 이 코드를 이 프로젝트에서 수정할 것입니다.

- vga.c, vga.h VGA 디스플레이 드라이버입니다. 화면에 텍스트를 쓰는 역할을 합니다. 이 코드를 살펴볼 필요가 없어야 합니다. printf() 호출은 VGA 디스플레이 드라이버로 진행되므로 직접 이 코드를 호출할 필요는 거의 없습니다.

- serial.c, serial.h 시리얼 포트 드라이버입니다. 다시 말하지만, printf()는 이 코드를 대신 호출하므로 직접 이 코드를 사용할 필요가 없습니다. 시리얼 입력은 입력 레이어에 전달하여 처리됩니다 (아래 참조).

- block.c, block.h 블록 디바이스에 대한 추상화 레이어로, 고정 크기 블록 배열로 구성된 랜덤 액세스 디스크와 같은 디바이스입니다. 기본 설정에서 Pintos는 두 종류의 블록 디바이스, 즉 IDE 디스크와 파티션을 지원합니다. 블록 디바이스는 프로젝트 2에서 사용됩니다.

- ide.c, ide.h 최대 4개의 IDE 디스크에서 섹터를 읽고 쓰는 것을 지원합니다.

- partition.c, partition.h 디스크의 파티션 구조를 이해하여 하나의 디스크를 여러 영역 (파티션)으로 나누어 독립적으로 사용할 수 있게 합니다.

- kbd.c, kbd.h 키보드 드라이버로서, 키 입력을 처리하고 입력 레이어로 전달합니다 (아래 참조).

- input.c, input.h 입력 레이어로서, 키보드나 시리얼 드라이버로 전달된 입력 문자를 대기열에 넣습니다.

- intq.c, intq.h
   인터럽트 큐로서, 커널 스레드와 인터럽트 핸들러 모두 액세스하려는 순환 큐를 관리합니다. 키보드 및 시리얼 드라이버에서 사용됩니다.

- rtc.c, rtc.h
   실시간 시계 드라이버로서, 커널이 현재 날짜와 시간을 결정할 수 있게 합니다. 기본적으로 이것은 랜덤 숫자 생성기의 초기 시드를 선택하는 데 thread/init.c에서만 사용됩니다.

- speaker.c, speaker.h
   PC 스피커에서 소리를 생성할 수 있는 드라이버입니다.

- pit.c, pit.h
   8254 프로그래밍 가능 인터럽트 타이머를 구성하는 코드입니다. 이 코드는 devices/timer.c와 devices/speaker.c 모두에서 사용됩니다. 각 디바이스가 PIT의 출력 채널 중 하나를 사용하기 때문입니다.

 
### 1.4. `lib` 코드
마침내, lib 및 lib/kernel에는 유용한 라이브러리 루틴이 포함되어 있습니다. (lib/user는 프로젝트 2에서부터 사용될 것이지만 커널의 일부는 아닙니다.) 다음은 몇 가지 자세한 내용입니다.

ctype.h, inttypes.h, limits.h, stdarg.h, stdbool.h, stddef.h, stdint.h, stdio.c, stdio.h, stdlib.c, stdlib.h, string.c, string.h

표준 C 라이브러리의 일부입니다.

debug.c, debug.h

디버깅을 지원하기 위한 함수 및 매크로입니다. 자세한 정보는 디버깅 도구를 참조하세요.

random.c, random.h

의사 난수 생성기입니다. 실제 랜덤 값의 시퀀스는 Pintos 실행 간에 변하지 않습니다.

round.h

반올림을 위한 매크로입니다.

syscall-nr.h

시스템 호출 번호입니다. 프로젝트 2 이전에는 사용되지 않습니다.

kernel/list.c, kernel/list.h

이중 연결 리스트 구현입니다. Pintos 코드 전반에 사용되며, 프로젝트 1에서 몇 군데에서 직접 사용하게 될 것입니다. 시작하기 전에 이 코드를 훑어보는 것이 좋습니다(특히 헤더 파일의 주석을 확인하세요).

kernel/bitmap.c, kernel/bitmap.h

비트맵 구현입니다. 필요하면 코드에서 사용할 수 있지만, 프로젝트 1에서는 아마 필요하지 않을 것입니다.

kernel/hash.c, kernel/hash.h

해시 테이블 구현입니다. 프로젝트 3에서 유용할 것입니다.

kernel/console.c, kernel/console.h, kernel/stdio.h

printf() 및 기타 몇 가지 함수를 구현합니다.

 
### 1.5. 동기화 Synchronization

적절한 동기화는 이러한 문제의 해결에 중요한 부분입니다. 어떤 동기화 문제든 인터럽트를 비활성화하면 쉽게 해결할 수 있습니다. 인터럽트가 비활성화되어 있을 때에는 동시성이 없으므로 경합 조건의 가능성이 없습니다. 그러므로 모든 동기화 문제를 이 방식으로 해결하려는 유혹이 있을 수 있지만 그렇게 하지 마십시오. 대신, 세마포어, 락 및 조건 변수를 사용하여 대부분의 동기화 문제를 해결하세요. 동기화 원시 기본 요소가 어떤 상황에서 사용될 수 있는지 모를 경우 동기화에 대한 투어 섹션(동기화 참조) 또는 스레드/synch.c의 주석을 읽으세요.


Pintos 프로젝트에서 인터럽트를 비활성화하면 가장 적합한 문제 해결 클래스는 커널 스레드와 인터럽트 핸들러 간에 공유되는 데이터를 조정하는 것입니다. 인터럽트 핸들러는 슬립할 수 없으므로 락을 얻을 수 없습니다. 따라서 커널 스레드와 인터럽트 핸들러 간에 공유되는 데이터는 인터럽트를 끄는 방식으로 보호되어야 합니다.
이 프로젝트에서는 인터럽트 핸들러에서 스레드 상태를 약간만 액세스해야 합니다. 알람 시계의 경우 타이머 인터럽트는 슬립 중인 스레드를 깨워야 합니다. 고급 스케줄러에서는 타이머 인터럽트가 일부 전역 및 스레드별 변수에 액세스해야 합니다. 이러한 변수를 커널 스레드에서 액세스할 때 타이머 인터럽트가 간섭하는 것을 방지하기 위해 인터럽트를 비활성화해야 합니다.


인터럽트를 비활성화할 때는 가능한 한 코드 양을 최소화하기 위해 주의해야 합니다. 그렇지 않으면 타이머 틱이나 입력 이벤트와 같은 중요한 것들을 잃을 수 있습니다. 또한 인터럽트를 비활성화하면 인터럽트 처리 지연 시간이 증가하므로 너무 많이 사용하면 컴퓨터가 느려질 수 있습니다.


synch.c의 동기화 원시 기본 요소 자체는 인터럽트를 비활성화하여 구현됩니다. 여기에서 인터럽트를 비활성화하는 코드 양을 늘려야 할 수도 있지만 최소한으로 유지하려 노력해야 합니다.


인터럽트를 비활성화하는 것은 디버깅에 유용할 수 있으며 특정 코드 섹션을 인터럽트로부터 보호하려는 경우에 사용될 수 있습니다. 프로젝트를 제출하기 전에 디버깅 코드를 제거해야 합니다. (주석 처리만 하지 마세요. 이렇게 하면 코드가 해독하기 어려워질 수 있습니다.)


제출한 코드에는 바쁜 대기가 없어야 합니다. thread_yield()를 호출하는 긴 루프는 바쁜 대기의 한 형태입니다.


### 1.6. 개발 제안
과거에는 많은 그룹이 과제를 작은 조각으로 나누고 각 그룹원이 마감일 바로 전까지 자신의 부분에 작업을 했으며, 그룹은 그 이후에 코드를 결합하고 제출하는 방식을 사용했습니다. 이는 좋지 않은 아이디어입니다. 이러한 접근 방식은 충돌하는 두 가지 변경 사항이 발생하면 많은 마지막 순간 디버깅이 필요하게 되는 경우가 많습니다. 이런 방식으로 작업한 몇몇 그룹은 컴파일되거나 부팅하지 않는 코드를 제출하기도 했고, 테스트를 통과하지 못했습니다.


대신, 소스 코드 관리 시스템인 git과 같은 시스템을 사용하여 팀의 변경 사항을 조기에 자주 통합하는 것을 권장합니다. 이는 누구나 코드가 완성될 때가 아니라 작성 중인 코드를 볼 수 있으므로 덜 놀랍게 나타납니다. 이러한 시스템은 변경 사항 검토 및 변경 사항이 버그를 도입할 때 코드의 작동 버전으로 되돌릴 수 있도록 만들어줍니다.


이 프로젝트 및 이후 프로젝트를 진행하면서 이해할 수 없는 버그에 부딪힐 것으로 예상됩니다. 그럴 때는 디버깅 도구에 관한 부록을 다시 읽어보세요. 유용한 디버깅 팁으로 이루어져 있으며 속도를 내기 위한 도움이 될 것입니다 (디버깅 도구 참조). 커널 패닉 또는 어설션 오류를 최대한 활용하려면 백트레이스(Backtraces 참조) 섹션도 읽어보세요.


## 2. Alarm Clock

알람 시계

`devices/timer.c`에서 정의된 `timer_sleep()`를 다시 구현하세요. 작동하는 구현체가 제공되지만, 바쁘게 대기합니다. 즉, 현재 시간을 확인하고 `thread_yield()`를 호출하는 루프에서 회전하여 충분한 시간이 경과할 때까지 대기합니다. 바쁘게 대기하지 않도록 다시 구현하세요.

```c
void timer_sleep (int64_t ticks);
```
호출 스레드의 실행을 일시 중지하고 타이머 틱으로 측정된 시간이 최소한 x 만큼 경과할 때까지 기다립니다. 시스템이 다른 일로 인해 유휴 상태가 아니라면, 스레드는 정확히 x 틱 후에 깨어날 필요는 없습니다. 그들이 올바른 시간 동안 기다린 후 준비 큐에 넣으면 됩니다.

`timer_sleep()`는 실시간으로 작동하는 스레드에 유용합니다. 예를 들어, 커서를 초당 한 번 깜박이기 위해 사용됩니다. `timer_sleep()`의 인수는 밀리초나 다른 단위가 아닌 타이머 틱으로 표현됩니다. 초당 `TIMER_FREQ` 타이머 틱이 있으며, `TIMER_FREQ`는 `devices/timer.h`에서 정의된 매크로입니다. 기본값은 100입니다. 이 값을 변경하는 것은 많은 테스트가 실패할 가능성이 높으므로 추천하지 않습니다.

특정 밀리초, 마이크로초, 나노초 동안 대기하기 위한 별도의 함수인 `timer_msleep()`, `timer_usleep()`, `timer_nsleep()`가 있지만 필요한 경우 자동으로 `timer_sleep()`를 호출합니다. 이들을 수정할 필요는 없습니다. 알람 시계 구현은 나중의 프로젝트에 필요하지 않지만, 프로젝트 4에는 유용할 수 있습니다.


## 3. Priority Scheduling
우선순위 스케줄링
Pintos에서 우선순위 스케줄링과 우선순위 기증을 구현하세요.

현재 실행 중인 스레드보다 높은 우선순위를 가진 스레드가 준비 목록에 추가되면 현재 스레드는 즉시 새 스레드에 프로세서를 양보해야 합니다. 마찬가지로, 스레드가 락, 세마포어, 조건 변수를 기다리고 있을 때, 대기 중인 가장 높은 우선순위의 스레드가 먼저 깨어나야 합니다. 스레드는 언제든지 자신의 우선순위를 높이거나 낮출 수 있지만, 더 이상 가장 높은 우선순위를 가지지 않게 우선순위를 낮추면 즉시 CPU를 양보해야 합니다.

스레드 우선순위는 PRI_MIN (0)에서 PRI_MAX (63)까지 범위합니다. 낮은 숫자는 낮은 우선순위를 나타내므로 우선순위 0은 가장 낮은 우선순위이고 우선순위 63은 가장 높습니다. 초기 스레드 우선순위는 thread_create()에 인수로 전달됩니다. 다른 우선순위를 선택할 이유가 없다면 PRI_DEFAULT (31)을 사용하세요. PRI_ 매크로는 threads/thread.h에서 정의되며, 그 값을 변경해서는 안됩니다.

우선순위 스케줄링의 문제점 중 하나는 "우선순위 반전"입니다. H, M, L을 각각 높은, 중간, 낮은 우선순위의 스레드라고 가정해보세요. H가 L을 기다려야하는 경우(예: L이 보유한 락 때문에) 및 M이 준비 목록에 있으면, 낮은 우선순위 스레드는 CPU 시간을 얻지 못하기 때문에 H는 CPU를 절대 얻지 못합니다. 이 문제에 대한 부분적인 해결책은 H가 락을 보유 중인 동안 L에게 자신의 우선순위를 "기증"하고, L이 락을 해제하면(따라서 H가 락을 획득하면) 기증을 회수하는 것입니다.

우선순위 기증을 구현하세요. 우선순위 기증이 필요한 모든 다른 상황을 고려해야 합니다. 단일 스레드에 기증된 여러 우선순위에서 여러 기증을 처리하는 것을 확실히 해야 합니다. 중첩된 기증도 처리해야 합니다: H가 M이 보유하고 있는 락을 기다리고 M이 L이 보유한 락을 기다리면 M과 L 모두 H의 우선순위로 상승해야 합니다. 필요한 경우 중첩된 우선순위 기증의 깊이에 합리적인 제한을 두도록 할 수 있습니다, 예를 들면 8 레벨입니다.

락에 대한 우선순위 기증을 구현해야 합니다. 다른 Pintos 동기화 구조에 대한 우선순위 기증을 구현할 필요는 없습니다. 모든 경우에 우선순위 스케줄링을 구현해야 합니다.

마지막으로, 스레드가 자신의 우선순위를 검사하고 수정할 수 있게 하는 다음 함수들을 구현하세요. 이러한 함수들의 스켈레톤은 threads/thread.c에 제공됩니다.

```c
void thread_set_priority (int new_priority);
```
현재 스레드의 우선순위를 새 우선순위로 설정합니다. 현재 스레드가 더 이상 가장 높은 우선순위를 가지지 않으면 양보합니다.

```c
int thread_get_priority (void);
```
현재 스레드의 우선순위를 반환합니다. 우선순위 기증이 있을 경우 더 높은 (기증된) 우선순위를 반환합니다. 

스레드가 다른 스레드의 우선순위를 직접 수정할 수 있는 인터페이스를 제공할 필요는 없습니다.

우선순위 스케줄러는 나중의 프로젝트에서 사용되지 않습니다.

## 4. Advanced Scheduler
고급 스케줄러
시스템에서 실행되는 작업의 평균 응답 시간을 줄이기 위해 4.4BSD 스케줄러와 유사한 다단계 피드백 큐 스케줄러를 구현하세요.

우선순위 스케줄러와 마찬가지로 고급 스케줄러는 우선순위를 기반으로 실행할 스레드를 선택합니다. 그러나 고급 스케줄러는 우선순위 기증을 하지 않습니다. 따라서 우선순위 스케줄러를 우선순위 기증을 제외하고 작동하도록 만든 다음에 고급 스케줄러 작업을 시작하는 것이 좋습니다.

Pintos 시작 시간에 스케줄링 알고리즘 정책을 선택할 수 있도록 코드를 작성해야 합니다. 기본적으로 우선순위 스케줄러가 활성화되어야 하지만 -mlfqs 커널 옵션으로 4.4BSD 스케줄러를 선택할 수 있어야 합니다. 이 옵션을 전달하면 main()에서 일찍 parse_options()에 의해 옵션이 구문 분석될 때 threads/thread.h에서 선언된 thread_mlfqs를 true로 설정합니다.

4.4BSD 스케줄러가 활성화되면 스레드는 더 이상 직접 자신의 우선순위를 제어하지 않습니다. thread_create()에 대한 우선순위 인수는 무시해야하며, thread_set_priority()에 대한 모든 호출도 무시하고, thread_get_priority()는 스케줄러에 의해 설정된 스레드의 현재 우선순위를 반환해야 합니다. 고급 스케줄러는 나중의 프로젝트에서 사용되지 않습니다.

4.4BSD 스케줄러
일반적인 목적의 스케줄러의 목표는 스레드의 다양한 스케줄링 요구 사항을 균형있게 조절하는 것입니다. 많은 I/O를 수행하는 스레드는 입력 및 출력 장치를 바쁘게 유지하기 위해 빠른 응답 시간이 필요하지만, CPU 시간은 거의 필요하지 않습니다. 반면, 계산 집약적인 스레드는 작업을 완료하기 위해 많은 CPU 시간이 필요하지만, 빠른 응답 시간에 대한 요구 사항이 없습니다. 기타 스레드는 I/O를 중심으로 계산의 시기가 있으며, 시간에 따라 요구 사항이 다릅니다. 잘 설계된 스케줄러는 이러한 요구 사항을 모두 동시에 수용할 수 있습니다.

프로젝트 1에서는 이 부록에서 설명하는 스케줄러를 구현해야 합니다. 우리의 스케줄러는 [McKusick]에서 설명된 것과 유사한 다단계 피드백 큐 스케줄러의 예입니다. 이 유형의 스케줄러는 준비된 스레드의 여러 대기열을 유지합니다. 각 대기열은 다른 우선순위의 스레드를 보유하고 있습니다. 어느 시점에서든 스케줄러는 가장 높은 우선순위의 비어 있지 않은 대기열에서 스레드를 선택합니다. 가장 높은 우선순위 대기열에 여러 스레드가 있는 경우 "라운드 로빈" 순서로 실행됩니다.

스케줄러의 여러 측면은 타이머 틱이 지정된 횟수 후에 데이터가 업데이트되어야 합니다. 모든 경우에 이러한 업데이트는 일반 커널 스레드가 실행될 기회가 있기 전에 발생해야하므로 커널 스레드가 새로 증가한 timer_ticks() 값을 볼 가능성이 없지만 오래된 스케줄러 데이터 값을 볼 수 있습니다.

4.4BSD 스케줄러에는 우선순위 기증이 포함되어 있지 않습니다.

#### 좋은 의지(Niceness)
스레드 우선순위는 스케줄러가 아래에서 주어진 공식을 사용하여 동적으로 결정됩니다. 그러나 각 스레드에는 다른 스레드에 대해 얼마나 "좋은" 스레드가 될지 결정하는 정수 좋은 값이 있습니다. 좋은 값이 0이면 스레드 우선순위에 영향을 주지 않습니다. 긍정적인 좋은 값을 가지면 스레드의 우선순위가 감소하고 그렇지 않으면 받을 CPU 시간을 포기합니다. 반면에, 부정적인 좋은 값을 가진 스레드는 다른 스레드로부터 CPU 시간을 뺏어갑니다.

초기 스레드는 좋은 값 0으로 시작합니다. 다른 스레드는 부모 스레드로부터 좋은 값을 상속받아 시작합니다. 테스트 프로그램에서 사용하기 위해 아래에 설명된 함수들을 구현해야 합니다. threads/thread.c에 그들의 스켈레톤 정의를 제공했습니다.

```c
int thread_get_nice (void);
```
현재 스레드의 좋은 값을 반환합니다.

```c
int thread_set_nice (int nice);
```
현재 스레드의 좋은 값을 새로운 좋은 값으로 설정하고 새 값에 기반하여 스레드의 우선순위를 다시 계산합니다(우선순위 계산 참조). 실행 중인 스레드가 더 이상 가장 높은 우선순위를 가지지 않으면 양보합니다.

#### 우선순위 계산
우리의 스케줄러는 64개의 우선순위와 따라서 0(PRI_MIN)부터 63(PRI_MAX)까지의 64개의 준비 대기열을 가지고 있습니다. 낮은 숫자는 낮은 우선순위를 나타내므로 우선순위 0은 가장 낮은 우선순위이고 우선순위 63은 가장 높습니다. 스레드 우선순위는 스레드 초기화시 처음에 계산됩니다. 또한 매 네 번째 클록 틱마다 모든 스레드에 대해 다시 계산됩니다. 어느 경우에나 다음 공식에 의해 결정됩니다:

```c
priority = PRI_MAX - (recent_cpu / 4) - (nice * 2)
```

여기서 recent_cpu는 스레드가 최근에 사용한 CPU 시간의 추정치이고, nice는 스레드의 좋은 값입니다. 결과는 가장 가까운 정수로 내림되어야 합니다(절삭). recent_cpu와 nice에 대한 1/4 및 2의 계수는 실제로 잘 작동하지만 더 깊은 의미를 갖지 않습니다. 계산된 우선순위는 항상 PRI_MIN과 PRI_MAX 사이의 유효 범위에 조정됩니다.

이 공식은 스레드가 최근에 CPU 시간을받은 경우 다음에 스케줄러가 실행될 때 CPU를 재할당하기 위한 낮은 우선순위를 제공합니다. 이것은 굶주림을 방지하는 핵심입니다: 스레드가 최근에 CPU 시간을받지 못한 경우 recent_cpu의 값은 0이되어, 높은 좋은 값이 없는 한 곧 CPU 시간을받을 것으로 보입니다.

#### recent_cpu 계산
recent_cpu를 사용하여 각 프로세스가 "최근"받은 CPU 시간을 측정하려고 합니다. 더 나은 것으로, 최근 CPU 시간은 덜 최근 CPU 시간보다 더 무겁게 가중되어야 합니다. 한 가지 접근법은 최근 n 초 동안 받은 CPU 시간을 추적하기 위해 n 개의 요소로 구성된 배열을 사용하는 것입니다. 그러나 이 방법은 스레드당 O(n) 공간과 새로운 가중 평균 계산의 O(n) 시간이 필요합니다.

대신, 지수 가중 이동 평균을 사용합니다. 일반적인 형태는 다음과 같습니다:

```c
x(0) = f(0),
x(t) = ax(t − 1) + (1 − a)f(t),
a = k/(k + 1)
```

여기서 x(t)는 정수 시간 t ≥ 0에서의 이동 평균이고, f(t)는 평균되는 함수이며, k > 0은 감쇠율을 제어합니다. 우리는 몇 단계 동안 공식을 반복할 수 있습니다:

```c
x(1) = f(1),
x(2) = af(1) + f(2),
...
x(5) = a^4 * f(1) + a^3 * f(2) + a^2 * f(3) + a * f(4) + f(5)
```

f(t) 값은 시간 t에서 가중치 1을 가지며, 시간 t + 1에서는 가중치 a를 가지고, 시간 t + 2에서는 a^2를 가지고, 그리고 그렇게 됩니다. 또한 x(t)를 k와 관련시킬 수 있습니다: f(t)는 시간 t + k에서 약 1

/e의 가중치를 가지며, 시간 t + 2k에서는 약 1/(e^2)의 가중치를 가집니다. 반대 방향에서, f(t)는 시간 t + log_a(w)에서 가중치 w로 감쇠됩니다.

처음 생성된 스레드의 recent_cpu의 초기 값은 0이거나, 다른 새 스레드에서는 부모의 값입니다. 타이머 인터럽트가 발생할 때마다 실행 중인 스레드의 recent_cpu만 1 씩 증가합니다. 또한 1초에 한 번, 모든 스레드의 recent_cpu 값(실행 중인 것, 준비된 것 또는 차단된 것)이 이 공식을 사용하여 다시 계산됩니다:

```c
recent_cpu = (2 * load_avg)/(2 * load_avg + 1) * recent_cpu + nice
```

여기서 load_avg는 실행할 준비가 된 스레드 수의 이동 평균입니다(아래 참조). load_avg가 1인 경우, 평균적으로 단일 스레드가 CPU와 경쟁하므로 recent_cpu의 현재 값은 log_(2/3) .1 ≈ 6 초에서 .1의 가중치로 감소됩니다. load avg가 2인 경우 .1의 가중치로 감쇠되는 데 log_(3/4) .1 ≈ 8 초가 걸립니다. 효과는 recent cpu가 "최근"에 받은 CPU 시간의 양을 추정하며, CPU와 경쟁하는 스레드 수에 반비례하여 감쇠율이 있습니다.

몇몇 테스트에서 가정된 것처럼 recent cpu의 이러한 재계산은 시스템 틱 카운터가 초의 배수에 도달할 때 정확히 수행되어야 하며, 다른 어떤 때에도 수행되어서는 안됩니다.

recent_cpu의 값은 부정적인 좋은 값이 있는 스레드에 대해 음수일 수 있습니다. 음수 recent_cpu를 0으로 제한하지 마십시오.

이 공식에서 계산 순서에 대해 생각해볼 수 있습니다. recent cpu의 계수를 먼저 계산한 다음 곱하는 것이 좋습니다. 일부 학생들은 recent_cpu에 load_avg를 직접 곱하면 오버플로가 발생할 수 있다고 보고했습니다.

다음 함수를 구현해야 합니다. threads/thread.c에 대한 스켈레톤이 있습니다.

```c
int thread_get_recent_cpu (void);
```

현재 스레드의 recent cpu 값을 가장 가까운 정수로 반올림하여 100배하여 반환합니다.

#### load_avg 계산
마지막으로, load avg는 종종 시스템 부하 평균으로 알려져 있으며, 지난 1분 동안 실행 준비가 된 스레드의 평균 수를 추정합니다. recent_cpu와 마찬가지로 지수 가중 이동 평균입니다. load_avg는 시스템 전체가 아니라 스레드별로 아닙니다. 시스템 부팅시 0으로 초기화됩니다. 그 후 매 초마다 다음 공식에 따라 업데이트됩니다:

```c
load_avg = (59/60) * load_avg + (1/60) * ready_threads
```

여기서 ready_threads는 업데이트 시점에 실행 중이거나 실행 준비가 된 스레드 수입니다(유휴 스레드 제외).

몇몇 테스트에서 가정한 바와 같이 load_avg는 시스템 틱 카운터가 초의 배수에 도달할 때 정확히 업데이트되어야 하며, timer_ticks

()가 0을 반환하는 경우를 제외하고는 load_avg를 업데이트해서는 안됩니다.

load_avg의 값은 0 아래로 내려갈 수 없습니다.

이 함수를 구현해야 합니다. threads/thread.c에 스켈레톤이 있습니다.

```c
int thread_get_load_avg (void);
```

load avg 값을 가장 가까운 정수로 반올림하고 100배하여 반환합니다.

완료된 스케줄러는 thread_mlfqs 글로벌 변수를 사용하여 threads/thread.c에서 2곳에 있는 스케줄링 루틴과 공동으로 동작해야 합니다.

#### Summary
다음 공식들은 스케줄러를 구현하는 데 필요한 계산을 요약한 것입니다. 이들은 스케줄러 요구사항의 완전한 설명이 아닙니다.

모든 스레드는 그들의 직접적인 제어 아래에서 -20과 20 사이의 nice 값을 가집니다. 각 스레드는 또한 0 (PRI_MIN)에서 63 (PRI_MAX) 사이의 우선 순위를 가지며, 이는 다음 공식을 사용하여 매 네 번째 틱마다 다시 계산됩니다:

```c
priority = PRI_MAX - (recent_cpu / 4) - (nice * 2)
```

recent_cpu는 스레드가 "최근"에 받은 CPU 시간의 양을 측정합니다. 타이머 틱이 발생할 때마다 실행 중인 스레드의 recent_cpu는 1씩 증가합니다. 1초에 한 번, 모든 스레드의 recent_cpu는 다음과 같은 방식으로 업데이트됩니다:

```c
recent_cpu = (2 * load_avg) / (2 * load_avg + 1) * recent_cpu + nice
```

load_avg는 지난 1분 동안 실행을 준비한 스레드의 평균 수를 추정합니다. 부팅 시에 0으로 초기화되며, 그 후 매 초마다 다음과 같이 재계산됩니다:

```c
load_avg = (59/60) * load_avg + (1/60) * ready_threads
```

여기서 ready_threads는 업데이트 시점에 실행 중이거나 실행 준비가 된 스레드 수입니다(유휴 스레드 제외).

#### 고정 소수점 산술
위의 공식에서 priority, nice, ready_threads는 정수이지만, recent_cpu와 load_avg는 실수입니다. 불행히도 Pintos는 커널에서 부동 소수점 산술을 지원하지 않습니다. 왜냐하면 이것은 커널을 복잡하게 만들고 느리게 만들 수 있기 때문입니다. 실제 커널들도 같은 이유로 종종 같은 제한을 가집니다. 이는 실제 양에 대한 계산이 정수를 사용하여 시뮬레이션되어야 함을 의미합니다. 이것은 어렵지 않지만, 많은 학생들이 어떻게 하는지 모릅니다. 이 섹션은 기본 사항을 설명합니다.

기본적인 아이디어는 정수의 가장 오른쪽 비트를 분수로 간주하는 것입니다. 예를 들어, 우리는 부호가 있는 32비트 정수의 가장 낮은 14비트를 분수 비트로 지정하여 정수 x가 x/(2^14)의 실수를 나타내게 할 수 있습니다. 이것은 17.14 고정 소수점 숫자 표현이라고 불립니다. 왜냐하면 소수점 앞에 17비트, 그 뒤에 14비트, 그리고 하나의 부호 비트가 있기 때문입니다. 17.14 형식의 숫자는 최대 (2^31 − 1)/(2^14) ≈ 131,071.999의 값을 나타냅니다.

p.q 고정 소수점 형식을 사용한다고 가정하고, f = 2^q라고 합시다. 위의 정의에 따라, 정수 또는 실수를 p.q 형식으로 변환하기 위해 f로 곱할 수 있습니다. 예를 들어, 17.14 형식에서 load_avg 계산에서 사용된 분수 59/60은 (59/60)2^14 = 16,110입니다. 고정 소수점 값을 정수로 변환하려면 f로 나눕니다. (C의 일반적인 / 연산자는 0을 향해 반올림합니다. 즉, 양수는 내림하고 음수는 올림합니다. 가장 가까운 것으로 반올림하려면 양수에 f / 2를 더하거나 음수에서 뺍니다.)

고정 소수점 숫자에 대한 많은 연산들은 간단합니다. x와 y를 고정 소수점 숫자라고 하고, n을 정수라고 합시다. 그러면 x와 y의 합은 x + y이고 그들의 차이는 x - y입니다. x와 n의 합은 x + n * f; 차이는 x - n * f; 제품은 x * n; 몫은 x / n입니다.

두 고정 소수점 값의 곱셈은 두 가지 문제점이 있습니다. 첫째, 결과의 소수점은 q 비트만큼 너무 왼쪽에 있습니다. 예를 들어, (59/60)(59/60)은 1보다 약간 작아야 하지만, 16,111 × 16,111 = 259,564,321은 2^14 = 16,384보다 훨씬 큽니다. q 비트를 오른쪽으로 이동하면, 259,564,321/2^14 = 15,842, 즉 약 0.97로 정확한 답을 얻게 됩니다. 둘째, 곱셈이 오버플로 될 수 있습니다, 비록 답이 표현 가능하다 해도. 예를 들어, 17.14 형식의 64는 64 × 2^14 = 1,048,576이며, 그 제곱인 64^2 = 4,096은 17.14 범위 내에 잘 들어맞지만, 1,048,576^2 = 2^40은 최대 부호가 있는 32비트 정수 값인 2^31 - 1보다 큽니다. 쉬운 해결책은 64비트 연산으로 곱셈을 수행하는 것입니다. 그러면 x와 y의 제품은 ((int64_t) x) * y / f가 됩니다.

두 고정 소수점 값의 나눗셈은 반대의 문제가 있습니다. 소수점이 너무 오른쪽에 있을 것이므로 나눗셈을 하기 전에 나뉘어지는 수를 q 비트 왼쪽으로 이동하여 이 문제를 해결합니다. 왼쪽 시프트는 나뉘어지는 수의 상위 q 비트를 버리는데, 64비트에서 나누기를 다시 수행하여 이 문제를 해결할 수 있습니다. 따라서 x가 y로 나누어지면 결과는 ((int64_t) x) * f / y가 됩니다.

이 섹션에서는 q비트 시프트 대신 f로 곱하거나 나누는 것을 지속적으로 사용하였는데, 그에는 두 가지 이유가 있습니다. 첫째, 곱셈과 나눗셈은 C의 시프트 연산자의 놀랍게도 우선순위를 갖지 않습니다. 둘째, 곱셈과 나눗셈은 음수 피연산자에 대해서 잘 정의되어 있지만, C의 시프트 연산자는 그렇지 않습니다. 구현할 때 이 문제점들을 주의해야 합니다.

다음 표는 C에서 고정 소수점 산술 연산을 어떻게 구현할 수 있는지를 요약한 것입니다. 표에서, x와 y는 고정 소수점 숫자, n은 정수, 고정 소수점 숫자는 p + q = 31인 부호가 있는 p.q 형식이며, f는 1 << q입니다: 

산술	| C
---------|---------
n을 고정 소수점으로 변환 |	n * f
x를 정수로 변환 (0쪽 반올림) | x / f
x를 정수로 변환 (가장 가까운 값으로 반올림) | x >= 0이면 (x + f / 2) / f, x <= 0이면 (x - f / 2) / f
x와 y를 더하기 | x + y
x에서 y 빼기 | x - y
x와 n 더하기 | x + n * f
x에서 n 빼기 | x - n * f
x와 y 곱하기 | ((int64_t) x) * y / f
x와 n 곱하기 | x * n
x를 y로 나누기 | ((int64_t) x) * f / y
x를 n으로 나누기 | x / n